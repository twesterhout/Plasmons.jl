var documenterSearchIndex = {"docs":
[{"location":"#Plasmons.jl-1","page":"Home","title":"Plasmons.jl","text":"","category":"section"},{"location":"#Installing-1","page":"Home","title":"Installing","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Plasmons.jl can be used either as a Julia package or as a standalone executable. The latter option is provided for people who do not care about Julia and just want to do physics. If you are one of them just download Plasmons.sif executable file from the Releases page and you are good to go.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Otherwise, install Plasmons.jl using Pkg:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"import Pkg; Pkg.add(url=\"https://github.com/twesterhout/Plasmons.jl\")","category":"page"},{"location":"#Using-the-executable-1","page":"Home","title":"Using the executable","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"After downloading the container (Plasmons.sif file) from the Releases page one can simply run it. It follows the UNIX philosophy and tries to do one thing and do it well.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The one thing is calculating polarizability chi (or dielectric function varepsilon). It can be described by the following two functions:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"beginaligned\n    left(H omega mu Tright) mapsto chi \n    left(chi Vright) mapsto varepsilon\nendaligned","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This means that if you provide a Hamiltonian H and frequency omega (and some information about the environment, namely chemical potential mu and temperature T), Plasmons.sif will compute chi(omega) for your system. If you additionally provide unscreened Coulomb interaction V, Plasmons.sif will compute varepsilon(omega) as well.","category":"page"},{"location":"#Algorithm-1","page":"Home","title":"Algorithm","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Within real-space RPA (Random Phase Approximation) the calculation of polarizability matrix chi(omega) amounts to evaluation of the following equation","category":"page"},{"location":"#","page":"Home","title":"Home","text":"beginaligned\n    chi_ab\n        = langle a hatchi b rangle\n        = 2cdot sum_ij langle i hat G j rangle\n           langle j  a rangle langle a  i rangle\n           langle i  b rangle langle b  j rangle  \n    G_ij\n        = langle i  hat G  j rangle\n        = fracf_i - f_jE_i - E_j - (hbaromega + ieta) \nendaligned","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Here E_is are energy eigenvalues, langle a  i rangle = psi_i (a) are energy eigenstates, f_i = f(E_i) is the occupation of the i'th state given by the Fermi-Dirac distribution, eta is Landau damping, and omega is the frequency.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"First of all, for a given temperature T and chemical potential mu, we compute occupation numbers f(E_i).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"    Plasmons.fermidirac","category":"page"},{"location":"#Plasmons.fermidirac","page":"Home","title":"Plasmons.fermidirac","text":"fermidirac(E; mu, kT) -> f\n\nReturn Fermi-Dirac distribution f at energy E, chemical potential mu, and temperature kT. Note that kT is assumed to be temperature multiplied by the Boltzmann constant, i.e. physical dimension of kT is the same as E (e.g. electron-volts).\n\n\n\n\n\n","category":"function"},{"location":"#","page":"Home","title":"Home","text":"Next, we compute the matrix G. This is done by either Plasmons._g or Plasmons._g_blocks functions.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"    Plasmons._g\n    Plasmons._g_blocks","category":"page"},{"location":"#Plasmons._g","page":"Home","title":"Plasmons._g","text":"_g(ħω, E; mu, kT) -> G\n\nwarning: Warning\nThis is an internal function!\n\nCompute matrix G\n\n    G_ij = fracf(E_i) - f(E_j)E_i - E_j - hbaromega\n\nwhere f is Fermi-Dirac distribution at chemical potential mu (mu) and temperature kT (k_B T). E is a vector of eigenenergies. ħω is a complex frequency including Landau damping (i.e.  hbaromega + ieta). All arguments are assumed to be in energy units.\n\nSometimes one can further exploit the structure of G. For E ll mu or E gg mu Fermi-Dirac distribution is just a constant and G goes to 0 for all omega. Plasmons._g_blocks uses this fact to construct a block-sparse version of G. The reason why such a block-sparse version is useful will become apparent later.\n\n\n\n\n\n","category":"function"},{"location":"#Plasmons._g_blocks","page":"Home","title":"Plasmons._g_blocks","text":"_g_blocks(ħω, E; mu, kT) -> (Gᵣ, Gᵢ)\n\nwarning: Warning\nThis is an internal function!\n\nCalculate matrix G given a vector of eigenenergies E, chemical potential mu, and temperature kT. See _g for the definition of G.\n\nCompared to _g this function applies to tricks:\n\nG is split into real and imaginary parts Gᵣ and Gᵢ.\nWe exploit the \"block-sparse\" structure of G (see Plasmons._ThreeBlockMatrix).\n\n\n\n\n\n","category":"function"},{"location":"#","page":"Home","title":"Home","text":"Let us now turn to the computation of polarizability matrix chi. The naive approach is to write 4 nested loops. However, this is tremendously slow! A slightly better approach which I used for my Bachelor thesis is to rewrite the computation of each chi_a b as a combination of GEMV and DOT operations:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"beginaligned\n    chi_a b\n        = sum_i j left(langle a  i rangle langle i  b rangleright)\n            G_i j\n            left(langle j  a rangle langle b  j rangleright)\n         = A(ab)^dagger G A(ab)  \n        textwhere  A(ab)_j = langle j  a rangle langle b  j rangle \nendaligned","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We use the following data structure to hold A as well as the temporary G A.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"    Plasmons._Workspace","category":"page"},{"location":"#Plasmons._Workspace","page":"Home","title":"Plasmons._Workspace","text":"_Workspace{<: AbstractArray}\n\nwarning: Warning\nThis is an internal data structure!\n\nA workspace which is used by polarizability function to avoid allocating many temporary arrays. Stores two attributes:\n\nA vector A which is defined by A_j = langle j  a rangle langle b  j rangle.\nA vector temp which is the product G A.\n\n\n\n\n\n","category":"type"},{"location":"#","page":"Home","title":"Home","text":"TODO: Finish this.","category":"page"}]
}
